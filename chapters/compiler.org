
[Intro]


#+caption: Compilation layers
#+NAME: fig:compilation_layers
#+ATTR_LATEX: :width \textwidth
[[file:figures/layers.png]]


****** cQASM

# Common QASM (cQASM) aims to abstract away qubit technology details
# and guarantee the interoperability between all the quantum
# compilation and simulation tools supporting this standard. Our
# vision is to enable an extensive quantum computing toolbox
# shared by all the quantum computing community.


****** OpenQL

# Intro (what is OpenQL, advantages, abilities, ...)

#+caption: OpenQL diagram
#+NAME: fig:openql
#+ATTR_LATEX: :width 0.9\textwidth
[[file:figures/openql.png]]

#+BEGIN_EXPORT latex
\begin{figure}
\centering
\begin{minipage}{\textwidth}
#+END_EXPORT

     #+BEGIN_SRC python

from openql import openql as ql
import os
import argparse

def circuit(config_file, scheduler='ASAP', uniform_sched= 'no', mapper='base', initial_placement='no', output_dir_name='test_output', optimize='no', measurement=True, log_level='LOG_WARNING'):
    curdir = os.path.dirname(__file__)
    output_dir = os.path.join(curdir, output_dir_name)
    ql.set_option('output_dir', output_dir)
    ql.set_option('optimize', optimize)
    ql.set_option('scheduler', scheduler)
    ql.set_option('scheduler_uniform', uniform_sched)
    ql.set_option('mapper', mapper)
    ql.set_option('initialplace', initial_placement)
    ql.set_option('log_level', log_level)

    config_fn = os.path.join(curdir, config_file)

    platform  = ql.Platform('starmon', config_fn)
    sweep_points = [1,2]
    num_circuits = 1
    num_qubits = 6
    p = ql.Program('graycode6', platform, num_qubits)
    p.set_sweep_points(sweep_points, num_circuits)
    k = ql.Kernel('graycode6', platform, num_qubits)
    k.gate('cnot',[1,0])
    k.gate('cnot',[2,1])
    k.gate('cnot',[3,2])
    k.gate('cnot',[4,3])
    k.gate('cnot',[5,4])

    if measurement:
        for q in range(num_qubits):
            k.gate('measure', [q])

    p.add_kernel(k)
    p.compile()
     
     #+END_SRC

#+BEGIN_EXPORT latex
\caption{OpenQL description in python code describing the Gray code algorithm.}
\label{code:openql_gray_code}
\end{minipage}
\end{figure}
#+END_EXPORT

#+BEGIN_EXPORT latex
\begin{figure}
\centering
\begin{minipage}{\textwidth}
#+END_EXPORT

     #+BEGIN_SRC js

{
   "eqasm_compiler" : "cc_light_compiler",

   "hardware_settings": {
	 "qubit_number": 7,
	 "cycle_time" : 20,  
     ...
   },

  "resources":
   {
    "qubits":
    {
      "description": "Each qubit can be used by only one gate at a time. There are 'count' qubits.",
      "count": 7
    },
    "qwgs" :
    {
      "description": "Single-qubit rotation gates (instructions of 'mw' type) are controlled by qwgs.  Each qwg controls a private set of qubits.  A qwg can control multiple qubits at the same time, but only when they perform the same gate and started at the same time. There are 'count' qwgs. For each qwg it is described which set of qubits it controls.",
      "count": 3,
      "connection_map":
      {
        "0" : [0, 1],
        "1" : [2, 3, 4],
        "2" : [5, 6]
      }
    },
    "meas_units" :
    {
      "description": "Single-qubit measurements (instructions of 'readout' type) are controlled by measurement units.  Each one controls a private set of qubits.  A measurement unit can control multiple qubits at the same time, but only when they started at the same time. There are 'count' measurement units. For each measurement unit it is described which set of qubits it controls.",
      "count": 2,
      "connection_map":
      {
        "0" : [0, 2, 3, 5, 6],
        "1" : [1, 4]
      }
    },
    "edges":
    {
      "description": "Two-qubit flux gates (instructions of 'flux' type) are controlled by qubit-selective frequency detuning.  Frequency-detuning may cause neighbor qubits (qubits connected by an edge) to inadvertently engage in a two-qubit flux gate as well. This happens when two connected qubits are both executing a two-qubit flux gate. Therefore, for each edge executing a two-qubit gate, certain other edges should not execute a two-qubit gate. There are 'count' edges. For each edge it is described which set of other edges cannot execute a two-qubit gate in parallel.",
      "count": 16,
      "connection_map":
      {
        "0": [2, 10], 
        ...
        "15": [5, 13]
      }
    },
    "detuned_qubits":
    {
      "description": "A two-qubit flux gate lowers the frequency of its source qubit to get near the frequency of its target qubit.  Any two qubits which have near frequencies execute a two-qubit flux gate.  To prevent any neighbor qubit of the source qubit that has the same frequency as the target qubit to interact as well, those neighbors must have their frequency detuned (lowered out of the way).  A detuned qubit cannot execute a single-qubit rotation (an instruction of 'mw' type).  An edge is a pair of qubits which can execute a two-qubit flux gate.  There are 'count' qubits. For each edge it is described, when executing a two-qubit gate for it, which set of qubits it detunes.",
      "count": 7,
      "connection_map":
      {
        "0": [3],
        ...
        "15": []
      }
    }
  },
  "topology" : 
  {
    "description": "A qubit grid is rectangular. The coordinates in the X direction are 0 to x_size-1. In the Y direction they are 0 to y_size-1. In the grid real qubits are placed. Each qubit has an id (its index, used above in the resource descriptions, and used below as operands to gates), an x and a y coordinate. Qubits are connected in directed pairs, called edges. Each edge has an id (its index, used above in the resource descriptions), a source qubit and a destination qubit.",
    "x_size": 5,
    "y_size": 3,
    "qubits": 
    [ 
      { "id": 0,  "x": 1, "y": 2 },
      ...
      { "id": 6,  "x": 3, "y": 0 }
    ],
    "edges": 
    [
      { "id": 0,  "src": 2, "dst": 0 },
      ...
      { "id": 15,  "src": 4, "dst": 6 }

    ]
  },

   "instructions": {

   "measure": {
      "duration": 320,
      "latency": 0,
      "matrix": [ [0.0,1.0], [1.0,0.0], [1.0,0.0], [0.0,0.0] ],
      "disable_optimization": false,
      "type": "readout",
      "cc_light_instr_type": "single_qubit_gate",
      "cc_light_instr": "measz",
      "cc_light_opcode": 4
   },
   "i": {
      "duration": 20,
      "latency": 0,
      "matrix": [ [0.0,1.0], [1.0,0.0], [1.0,0.0], [0.0,0.0] ],
      "disable_optimization": false,
      "type": "mw",
      "cc_light_instr_type": "single_qubit_gate",
      "cc_light_instr": "i",
      "cc_light_opcode": 5
   },
   "x": {
      "duration": 20,
      "latency": 0,
      "matrix": [ [0.0,1.0], [1.0,0.0], [1.0,0.0], [0.0,0.0] ],
      "disable_optimization": false,
      "type": "mw",
      "cc_light_instr_type": "single_qubit_gate",
      "cc_light_instr": "x",
      "cc_light_opcode": 6
   }

   ...

   },
    
    "gate_decomposition": {
	"cnot %0 %1": ["ym90 %1","cz %0 %1","ry90 %1"],
	"swap %0 %1": ["ym90 %1","cz %0 %1","ry90 %1", "ym90 %0","cz %1 %0","ry90 %0", "ym90 %1","cz %0 %1","ry90 %1"],
	"z %0" : ["x %0","y %0"],
    ...
    }
}

     
     #+END_SRC

#+BEGIN_EXPORT latex
\caption{JSON code that describe a quantum device characteristics and constrains}
\label{code:json_sc7}
\end{minipage}
\end{figure}
#+END_EXPORT

