
*** Intro                                                          :ignore:
# Intro (motivation/why do we need them?) and Objective

As stated in the Introduction, the research was conducted in order to analyze the different metrics to assert the quality of a mapping algorithm.
Consequently, we used a classic technique, the benchmarking technique.
In general computing, a benchmark is a program or a set of programs used to assess the performance of the host technology.
In our case, a benchmark would be a quantum algorithm that we will map to the SC chips constraints and then simulate aiming to use them to understand the different metrics.
Under this approach, it was decided that the best methodology would go through four different steps.

*** Methodology                                                    :ignore:

First, we built a list of quantum algorithms as benchmarks.
We opted to collect a big variety of different algorithms from different sources and libraries with a view to classify them and select the most interesting ones afterwards.
As it is common to find in the literature [REFER ALL THE PAPERS WITH LIST OF REAL BENCHMARKS], we also decided the benchmarks to be real and useful quantum algorithms, instead of random circuits.

from RevLib cite:Wille_2008, ScaffCC cite:JavadiAbhari_2015, Zulehner's paper cite:zulehner17:effic_method_mappin_quant_circuit and QLib cite:Lin_2014.


   Then I had to translate them from its QASM version to OpenQL.

   And finally compile them.


    Steps:
    
   1. Build algorithms list       
      1. Gather the algorithms from cite:zulehner17:effic_method_mappin_quant_circuit and cite:Lin_2014.
      2. Translate them from its QASM version to OpenQL.
      3. Compile OpenQL files to QASM.
   2. Algorithms profile (source, number of qubits, number of gates, gates percentage, ...).
   3. Algorithms classification.
   4. Check algorithm correctness.
      1. Are the original algorithms correct? $\to$ Check behaviour in the IBM Simulator.
      2. Is my translation correct? $\to$ Simulate them in QX and compare the results with the ones of the previous step.
      3. Are the algorithms working as expected? $\to$ check if the results are the ones that the algorithm should have.


*** Benchmarks Graph                                         :BMCOL:ignore:
    :PROPERTIES:
    :BEAMER_col: 0.6
    :END:

#+BEGIN_EXPORT latex

\begin{figure}
\centering
\resizebox{0.75\textwidth}{!}{
\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=0.7cm, thick,main node/.style={}]
    \fill[orange!40] (2,2) circle (.08cm) coordinate (Z);
    \fill[cyan!30] (3,6) circle (1.6cm) coordinate (R);
    \fill[purple!50] (7,5) circle (.1cm) coordinate (S);
    \fill[teal!40] (8,2) circle (1cm) coordinate (Q);
    \draw[gray,dashed] (5,4) ellipse (6cm and 4cm) coordinate (A);
    \draw (4,0) -- coordinate (L) (10,6.4) coordinate (Le);
 %\node[main node] (1) [left of R] {RevLib};
\node[main node] at (3,6) {RevLib};
\node[main node] (2) [above of=Z] {Others from Zulehner's paper};
\node[main node] (3) [above of=S] {ScaffCC};
%\node[main node] (4) [above right of Q] {QLib};
\node[main node] at (8,2) {QLib};
\node[main node,draw] (5) [above left  of=L] {OPENQASM};
\node[main node,draw] (6) [below of=Le] {QLib QASM};
\end{tikzpicture}
}
\label{fig:benchmarks_graph}
\caption{Graph depicting the amount of benchmarks per source. The line splits the source depending on the description programming language}
\end{figure}

#+END_EXPORT

*** Benchmarks data                                          :BMCOL:ignore:
    :PROPERTIES:
    :BEAMER_col: 0.3
    :END:
    
****                                                              :B_onlyenv:
     :PROPERTIES:
     :BEAMER_env: onlyenv
     :BEAMER_act: <1>
     :END:

    - OPENQASM
      - RevLib (55)
      - ScaffCC (3)
      - Others from Zulehner's paper (1)
    - QLib QASM
      - QLib (7)


****                                                              :B_onlyenv:
     :PROPERTIES:
     :BEAMER_env: onlyenv
     :BEAMER_act: <2>
     :END:

    - OPENQASM
      - RevLib (52)
      - +ScaffCC+ 
      - Others from Zulehner's paper (1)
    - QLib QASM
      - QLib (3)

*** Benchmarks data analysis

***                                                               :B_onlyenv:
    :PROPERTIES:
    :BEAMER_env: onlyenv
    :BEAMER_act: <1>
    :END:

    The Clifford+T quantum algorithms gathered are not in pure QASM:

***                                                               :B_onlyenv:
    :PROPERTIES:
    :BEAMER_env: onlyenv
    :BEAMER_act: <2>
    :END:

    After the translation, despite gates that OpenQL is not able to decompose yet, the compiled QASM files are:
    


*** OpenQL Translation                                              :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :BEAMER_act: <1>
    :END:

    So they should be translated to OpenQL an then compiled to QASM.

*** TODO                                                           :B_noteNH:
    :PROPERTIES:
    :BEAMER_env: noteNH
    :END:
    
    # *Introduce* The work that I've done    

#         #+BEGIN_EXPORT latex
# \begin{center} 
# \resizebox{0.5\textwidth}{!}{   
# \begin{tikzpicture}[sibling distance=3pt]
#   \tikzset{grow'=right,level distance=130pt}
#   \tikzset{execute at begin node=\strut}
#   \tikzset{every tree node/.style={align=center,anchor=base west}}
#   %% \tikzset{edge from parent/.style={draw,
#   %%     edge from parent path={(\tikzparentnode.east)
#   %%       -- +(0,-8pt)
#   %%       |- (\tikzchildnode)}}}
#   \tikzset{level 2/.style={level distance=120pt}}
#   %% \tikzset{level 3/.style={level distance=120pt}}
#   %% \tikzset{level 4/.style={level distance=100pt}}
#   %% \tikzset{frontier/.style={distance from root=500pt}}
#   \Tree [.{QLib Algorithms}
#     {QFT}
#     {IQFT}
#     {\textbf{Grover's Search}}
#     {Benstein-Vazirani Search}
#     [.{\textbf{Adder}}
#     {Cuccaro}
#     {Drapper}
#     {VBE}
#     ]
#     {\textbf{Quantum (Cuccaro) Multiplier}}
#     {Modular Exponential}
#     ]
#     \end{tikzpicture}
# }
# \end{center}
#     #+END_EXPORT


   Now, I'm going to show you how the benchmarks are.

   Most of them are written in OPENQASM and are from RevLib.

   Moreover, Leon has contributed uploading more, but I haven't merge those with the ones I am describing.

\hline

   Some of them have arbitrary rotation gates, which decomposition is not included yet in OpenQL, so I'm not going to translate them for now.


*** Benchmarks Classification

* Benchmarks formation and classification
    

** Benchmarks statistics

   # Also how the benchmarks are. I have to do here a bridge from the definition of the tasks to the work done.

*** Statistics
    
    - Number of different algorithms (without the decomposition): 53+3 = 56
    - The highest amount of gates: ~hwb9_119~ with 207775 gates

    
***                                                                   :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.4
    :END:

    You can find much more information in the [[https://github.com/QE-Lab/qbench][qbench]] repository in GitHub or in my thesis notes in ShareLaTeX.


*** TODO                                                           :B_noteNH:
    :PROPERTIES:
    :BEAMER_env: noteNH
    :END:

       After the translation, we have 56 different algorithms, in which the higgest amount of gates is around 208 000 gates.

   Also I'm going to show you how is the qbench repo right now.

    
    Things that may interest them:

    - See the OpenQL code and the QASM code
    - The organization of the repository
    - The Benchmarks profile
    - The configuration file of the compilation
   
# ** Algorithms Classification

# *** Classification                                                :B_onlyenv:
#     :PROPERTIES:
#     :BEAMER_act: <1>
#     :BEAMER_env: onlyenv
#     :END:

#     #+BEGIN_EXPORT latex
# \begin{center}    
# \begin{tikzpicture}[sibling distance=3pt]
#   \tikzset{grow'=right,level distance=130pt}
#   \tikzset{execute at begin node=\strut}
#   \tikzset{every tree node/.style={align=center,anchor=base west}}
#   %% \tikzset{edge from parent/.style={draw,
#   %%     edge from parent path={(\tikzparentnode.east)
#   %%       -- +(0,-8pt)
#   %%       |- (\tikzchildnode)}}}
#   \tikzset{level 2/.style={level distance=120pt}}
#   %% \tikzset{level 3/.style={level distance=120pt}}
#   %% \tikzset{level 4/.style={level distance=100pt}}
#   %% \tikzset{frontier/.style={distance from root=500pt}}
#   \Tree [.{Benchmarks Classes}
#     {Quantum Gates}
#     {Search Algorithms}
#     {Encoding Functions}
#     {Arithmetic Functions}
#     {Miscellaneous}
#     ]
#     \end{tikzpicture}
# \end{center}
#     #+END_EXPORT

# *** Classification                                                  :B_block:
#     :PROPERTIES:
#     :BEAMER_env: block
#     :END:

#     Based on the RevLib cite:Wille_2008 algorithm classification, for now, because most of the benchmarks come from that library.
# *** Classification                                                :B_onlyenv:
#     :PROPERTIES:
#     :BEAMER_act: <2>
#     :BEAMER_env: onlyenv
#     :END:

#     #+ATTR_LATEX: :booktabs :environment :font \tiny :width \textwidth :float t :align p{2.5cm}|p{3cm}p{3cm}
#     |                      |                     |                |
#     | Quantum gates        | Miller Gate         |                |
#     |----------------------+---------------------+----------------|
#     | Search Algorithms    | Grover's Search     |                |
#     |----------------------+---------------------+----------------|
#     |                      | Decod24             |                |
#     | Encoding Functions   | Decod24 with enable |                |
#     |                      | Graycode            |                |
#     |                      | Hamming Code        |                |
#     |----------------------+---------------------+----------------|
#     |                      | 0410184             | mlp4           |
#     |                      | 1-bit Adder / rd32  | mod5adder      |
#     |                      | 4 greater than 10   | mod5d1         |
#     |                      | 4 greater than 11   | mod5d2         |
#     |                      | 4 greater than 12   | mod5mils       |
#     |                      | 4 greater than 13   | plus127mod8192 |
#     |                      | 4 greater than 4    | plus63mod4096  |
#     |                      | 4 greater than 5    | plus63mod8192  |
#     | Arithmetic Functions | 4 modulo 7          | radd           |
#     |                      | ALUs                | rd32           |
#     |                      | Check 4 modulo 5    | rd53           |
#     |                      | Cuccaro Adder       | rd73           |
#     |                      | Cuccaro Multiplier  | rd84           |
#     |                      | Drapper Adder       | root           |
#     |                      | Modulo 8/10 Counter | sqn            |

# *** Classification                                                :B_onlyenv:
#     :PROPERTIES:
#     :BEAMER_act: <3>
#     :BEAMER_env: onlyenv
#     :END:

#     #+ATTR_LATEX: :booktabs :environment :font \tiny :width \textwidth :float t :align p{2.5cm}|p{2.5cm}p{3.5cm} 
#     |                      | One-Two-Three Counter | sqrt8                             |
#     |                      | VBE Adder             | squar5                            |
#     | Arithmetic Functions | dist                  | xor5                              |
#     |                      | majority              | z4                                |
#     |                      | max46                 |                                   |
#     |----------------------+-----------------------+-----------------------------------|
#     |                      | 9symml                | ex-1                              |
#     |                      | adr4                  | ex1                               |
#     |                      | aj-e11                | ex2                               |
#     |                      | C17                   | ex3                               |
#     |                      | clip                  | f2                                |
#     |                      | cm152a                | inc                               |
#     | Miscellaneous        | cm42a                 | life                              |
#     |                      | cm82a                 | misex1                            |
#     |                      | cm85a                 | pm1                               |
#     |                      | co14                  | sao2                              |
#     |                      | con1                  | sym10                             |
#     |                      | cycle10_2             | sym6                              |
#     |                      | dc1                   | sym9                              |
#     |                      | dc2                   | Unstructured Reversible Functions |
#     |                      | Hidden Weighted Bit   | 3_17                              |
#     |                      |                       | 4_49                              |


# *** TODO :B_noteNH:
#     :PROPERTIES:
#     :BEAMER_env: noteNH
#     :END:

#     Benchmark classes:

#     - Quantum Gates: Circuits that are a decomposition of a Quantum Gate
#     - Search Algorithms
#     - Worst Cases: Circuits that were really difficult to generate for RevLib
#       - HWB: is the simplesr function with exponential Ordered Binary Decision Diagrams (OBDD) size.
#     - Encoding Functions: Classical codification functions
#     - Arithmetic Functions: Functions that perform an arithmetic operation
#     - Miscellaneous: Mix of different kind of algorithms that we do not know its expected behaviour
    
*** TODO                                                         :B_noteNH:
    :PROPERTIES:
    :BEAMER_env: noteNH
    :END:

       After the building step, as I've already shown you, the profile realization and classification steps came.

   Finally, right now I'm checking the algorithm correctness.
    

    
*** BIB                                                   :ignore:noexport:

bibliography:../thesis_plan.bib
bibliographystyle:plain
